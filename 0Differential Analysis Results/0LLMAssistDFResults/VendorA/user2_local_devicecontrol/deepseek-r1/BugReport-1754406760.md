# BTB Semantic
```json
{
    "local_user1_DeviceControl": [
        [
            "Operation result: Success. Evidence: 'notifyType':'deviceDataChanged'; 'data':{'on':1}'. Reason: MQTT state-change notifications (deviceDataChanged) with device activation (on:1) confirm execution success; absence of explicit control-response acknowledgments introduces operational uncertainty despite consistent state updates."
        ]
    ],
    "local_user1_InviteAndAccept": [
        [
            ""
        ],
        [
            ""
        ],
        [
            "Operation result: Failed. Evidence: '200';'{'error_code':205002,'error_desc':'Home member is already exist in database.'}';'error_code':205002';'205002'. Reason: Critical member addition failure (error code 205002) indicating existing member, overriding HTTP 200 success indicators. User lookup failure also occurred but did not prevent endpoint access, though persistent member conflict invalidated final outcome."
        ],
        [
            "Operation result: Failed. Evidence: '205002';'error_code':205002';'{'error_code':205002,'error_desc':'Home member is already exist in database.'}'. Reason: Member addition conflict (205002) confirming existing member in database, compounded by fatal user lookup failure. No successful indicators overrode core errors."
        ]
    ],
    "local_user1_RemoveDevice": [
        [
            "Operation result: Success. Evidence: ''notifyType':'deviceDeleted''. Reason: Explicit device deletion confirmation via MQTT notifyType payload overriding operational context; protocol semantics conclusively match RemoveDevice action despite ancillary signals."
        ]
    ],
    "local_user1_RemoveFromHome": [
        [
            ""
        ],
        [
            "Operation result: Success. Evidence: '200'. Reason: Explicit success confirmation via HTTP 200 status code from DELETE request to member endpoint, with forensic packet analysis confirming operation alignment and exclusion of irrelevant traffic."
        ]
    ],
    "local_user2_DeviceControl": [
        [
            "Operation result: Success. Evidence: 'deviceDataChanged notification with {'st':'switch','data':{'on':1}}'; **''st':'switch','data':{'on':1}'**; **'{'st':'switch','data':{'on':1'**; ''notifyType':'deviceDataChanged','st':'switch','data':{'on':1}'. Reason: MQTT state update notifications confirm switch activation (on:1) with successful control execution; state changes occurred without observed user2 command packets."
        ],
        [
            ""
        ],
        [
            ""
        ],
        [
            "Operation result: Success. Evidence: 'deviceDataChanged notification with {'st':'switch','data':{'on':0}}'; **''st':'switch','data':{'on':0}'**; **'{'st':'switch','data':{'on':0'**; ''st':'switch','data':{'on':0}'. Reason: MQTT state update notifications confirm switch deactivation (on:0) with successful control execution; state changes occurred without observed user2 command packets."
        ]
    ],
    "remote_user1_DeviceControl": [
        [
            "Operation result: Success. Evidence: 'errcode':0. Reason: Command responses consistently indicate errcode 0 across protocol-level ACKs, confirming successful control execution with MQTT commandRsp alignment. Operational success is further evidenced by subsequent state synchronization."
        ]
    ],
    "remote_user2_DeviceControl": null
}
```

# State Semantic
## Base model
| State | Semantic Description |
|-------|----------------------|
| S0 | Initial state. |
| S1 | Error state. |
| S2 | user1 added the device once; user2 is not a family member and has no permissions. |
| S3 | user1 added the device once; user2 is a family member and has permanent control permissions. |
| S4 | user1 has not added any device; user2 is a family member and has permanent control permissions, but there are no devices to control. |

## Divergent model
| State | Semantic Description |
|-------|----------------------|
| S0    | Initial state. |
| S1    | user1 added the device once; user2 is not a family member and has no control permissions. |
| S2    | Error state. |
| S3    | user1 has not added the device; user2 is already a family member (family invitation failed). |
| S4    | user1 added the device once; user2 is a family member with permanent control permissions. |
| S5    | user1 added the device once; user2 (family member) retains control permissions after device interaction. |
| S6    | user1 removed the device; user2 remains a family member with no device to control. |
| S7    | user1 revoked user2's family membership; user2 has no permissions despite the device being present. |
| S8    | user1 removed the device and revoked user2's family membership; no active device or permissions exist. |
| S9    | user1 re-added the device and revoked user2's family membership; user2 has no permissions. |
| S10   | user1 re-added the device; user2 remains a family member with permanent control permissions. |

# Bug Reports
## Base model
*   No issues found.

## Divergent model
*   **Vulnerability 1: Unauthorized Device Control After Family Revocation**  
    *   **Impact:** User2 retains device control permissions after being removed from the family group, enabling persistent unauthorized device manipulation. This violates integrity/availability principles and demonstrates failure to properly revoke permissions, allowing attackers to maintain control through device re-addition cycles.  
    *   **Problematic State(s):**  
        *   `s7`: Performed **user2|local|DeviceControl**, received **CLS_0 (Success)**, transitioned to **State S7**, causing **unauthorized control despite explicit family membership revocation**.  
        *   `s9`: Performed **user2|local|DeviceControl**, received **CLS_3 (Success)**, transitioned to **State S9**, causing **persistent access after device removal/re-addition and family revocation**.  

*   **Vulnerability 2: Permission Reactivation via Device Re-addition**  
    *   **Impact:** User2 automatically regains control permissions when User1 re-adds a device, even after explicit family revocation. This violates least-privilege principles by reactivating permissions without explicit family membership re-establishment.  
    *   **Problematic State(s):**  
        *   `s10`: Transitioned to **s5** via **user2|local|DeviceControl** with **CLS_0 (Success)**, causing **implicit permission reactivation through device re-addition by User1**.  

*   **Vulnerability 3: State Inference via Response Code Patterns**  
    *   **Impact:** Differential response codes (CLS_0/CLS_3 vs CLS_NoResponse) for DeviceControl operations enable attackers to infer system state changes. Contrasting success codes between revoked membership states (s7 vs s9) and failed attempts (s8) creates detectable patterns that reveal permission status and device lifecycle changes.  
    *   **Problematic State(s):**  
        *   `s4` vs `s9`: **CLS_0** vs **CLS_3** responses for DeviceControl reveal differences between valid family membership and revoked-but-re-added device states.  
        *   `s7/s9`: Successful **CLS_0/CLS_3** vs `s8`'s **CLS_NoResponse** creates distinguishable patterns for permission status probing.  

*   **Vulnerability 4: Inconsistent Error Handling in Family Operations**  
    *   **Impact:** Discrepancies in error responses for InviteAndAccept operations across states (CLS_2 vs CLS_3) leak information about family membership conflicts. Attackers can distinguish between initial invitation failures and persistent membership issues through error code variations.  
    *   **Problematic State(s):**  
        *   `s0`: **InviteAndAccept** returns **CLS_2** (HTTP 200 with error_code 205002), indicating initial invitation failure.  
        *   `s3`: Same operation returns **CLS_3** (direct error_code 205002), revealing persistent family conflict state.